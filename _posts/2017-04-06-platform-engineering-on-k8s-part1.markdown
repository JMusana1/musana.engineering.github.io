---
layout: post
title: Platform Engineering on Kubernetes powered by Terraform, Argo, and FastAPI - Part 1
date: 2024-05-25 13:32:20 +0300
description: Explore the practical implementation of Platform Engineering using powerful tools like Terraform, Argo Events, Argo Workflows
img: i-rest.jpg # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [platformengineering, kubernetes]
---
The cloud-native landscape is constantly evolving, and new concepts often emerge, capturing the attention of the tech community. While some of these concepts are often a repackaging of existing practices, many of them bring meaningful improvements. Platform Engineering is one of them, offering an innovative approach to empowering software engineering organizations in the cloud-native era.

In practical terms, Platform Engineering focuses on designing and building toolchains and workflows that enable self-service capabilities for software engineering teams. Platform engineers provide an integrated product most often referred to as an “Internal Developer Platform” covering the operational necessities of the entire lifecycle of an application.

In this multi-part series, we'll dive deep into a practical implementation of Platform Engineering by building an internal developer platform (IDP) using common tools that platform and DevOps engineers are already familiar with, such as Terraform, Argo Events, Argo Workflows, and FastAPI.

## Table of Contents
- [Introduction ](#introduction)
- [Platform Components](#platform-components)
- [Platform Tools ](#platform-tools)
- [Prerequisites ](#prerequisites)
- [Implementation ](#implementation)
- [Summary ](#summary)

## Introduction
**A Unified Developer Experience:** Imagine a centralized platform where developers can call an api to provision and manage infrastructure, automate workflows, and build and deploy applications with ease. This platform would serve as a one-stop shop, eliminating the need for disparate tools and manual processes, ultimately reducing complexity and increasing productivity. The figure below provides a step-by-step illustration of what we will be building in this multi-part series.

![idp-main (1)](https://github.com/musana-engineering/idp/assets/151420844/0230bd49-167b-463e-9e5e-eb576e666c8a)

## Platform Components
Our internal developer platform will be built to include 5 core capabilities.

- **Infrastructure provisioning:** Enable developers to create cloud infrastructure resources that adhere to security and performance best practices while abstracting complexities such  as networking and security.  

- **Environment Deployment:** Enable developers to create new and fully provisioned environments whenever needed and also delete them when nolonger needed.

- **Application Deployment:** Enable developers to deploy applications based on various events, such as code commits or manual triggers,

- **Application Configuration:** Enable developers configure applications based on various events, such as code commits or manual triggers

- **Access Control:** Manage who can do what in a scalable way.

## Platform Tools
Before diving into the implementation details, let's familiarize ourselves with the key tools and technologies that will power our internal developer platform.

- **Kubernetes:** Kubernetes is the underlying foundation upon which our internal developer platform will be built. Kubernetes provides a strong and scalable environment for deploying and managing the various components of our solution, including Terraform, Argo Events, Argo Workflows, and FastAPI.

- **Terraform:** All cloud infrastructure resources created through our platform will be defined and managed by Terraform. This process will be abstracted from the developer and occur seamlessly behind the scenes when an API endpoint is called, such as when creating a virtual machine. You can read more about terraform **[here](https://www.terraform.io/)**

- **Argo Events:** Argo Events, an event-driven workflow automation framework for Kubernetes, will enable us to build event-driven applications and workflows. It seamlessly integrates with various event sources, such as webhooks, message queues, and Kubernetes resources, allowing us to trigger actions and workflows based on specific events. In our implementation, Argo Events will react to events generated by developers interacting with the FastAPI endpoints, enabling automated workflows and orchestration. You can read more **[here](https://argoproj.github.io/argo-events/)**

- **Argo Workflows:** Argo Workflows, a container-native workflow engine, will be our CI/CD pipelining solution.This includes cloud resource provisioning, configuration, and application deployments. Using Argo Workflow templates, we will create Terraform tasks for provisioning and Ansible scripts for configuration. You can read more **[here](https://argoproj.github.io/workflows/)**

- **FastAPI:** FastAPI, a modern and high-performance web framework for building APIs with Python, will be the frontend of our internal developer platform. Developers will interact with the platform's capabilities through intuitive APIs exposed by FastAPI. Additionally, FastAPI's built-in Swagger UI will provide a user-friendly interface for exploring and testing the available APIs, fostering self-service. You can read more **[here](https://fastapi.tiangolo.com/)**

## Prerequisites
To follow along with this multi-part series and implement the solution described above, we'll be using Microsoft Azure and Azure Kubernetes Service (AKS). To get started, you'll need the following prerequisites:

- A Microsoft Azure account with an active subscription. If you don't have an Azure account, you can sign up for **[a free trial](https://azure.microsoft.com/en-us/pricing/offers/ms-azr-0044p)**. 
- Ensure that you have the necessary permissions and access to create and manage resources within your Azure subscription.
- Install **kubectl**, a command-line tool for interacting with your Kubernetes cluster. Installation instructions can be found **[here](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/)**
- Install jq, a lightweight and flexible command-line JSON processor. Installation instructions can be found **[here](https://jqlang.github.io/jq/)**
- While not strictly required, I recommend using a modern code editor like **Visual Studio Code.** This will make it easier to work with the code samples and configuration files provided throughout the series.

**Note:** Having a good understanding of Kubernetes concepts and architecture will be beneficial as we'll be deploying and interacting with Kubernetes throughout the series. Please note the principles and tools discussed in this series are transferable to other cloud providers and Kubernetes distributions, allowing you to adapt the solution to your preferred environment.

## Implementation: 
In this first part of the series, we'll focus on setting up the foundational infrastructure and services required for our internal developer platform implementation in Microsoft Azure. We will define our infrastructure requirements using Terraform. This includes provisioning a Virtual Network, Azure Kubernetes cluster, configuring network security settings and setting up the necessary storage resources.

- ### Foundation Architecture
![Blank diagram (1)](https://github.com/musana-engineering/internaldevplatform/assets/151420844/30f02448-fdd3-4d08-a150-b03fc1a97c91)
### Deployment steps
- Let's begin by deploying the core network.

{% highlight javascript %}
// Clone the project repository
git clone https://github.com/musana-engineering/idp.git

// Navigate to the network directory
cd idp/core/network

// Login to Azure CLI
az login

// Specify the Subscription to use via the following command:
export SUBSCRIPTION_ID=$(az account show --query id -o tsv)

// Create the service principal and store the output in a variable
export SERVICE_PRINCIPAL=$(az ad sp create-for-rbac \
--name sp-terraform \
--role="Owner" \
--scopes="/subscriptions/$SUBSCRIPTION_ID" \
--query "[appId, password, tenant]" -o json)

// Extract and export the client ID, client secret, and tenant ID
export ARM_CLIENT_ID=$(echo $sp_output | jq -r '.[0]')
export ARM_CLIENT_SECRET=$(echo $sp_output | jq -r '.[1]')
export ARM_TENANT_ID=$(echo $sp_output | jq -r '.[2]')

// Generate and review the Terraform plan
terraform init
terraform plan

// Provision the infrastructure.
terraform apply
{% endhighlight %}

- Next, lets create the Kubernetes cluster.
{% highlight javascript %}
// Navigate to the aks directory
cd idp/core/aks

// Generate and review the Terraform plan
terraform init
terraform plan

// Provision the infrastructure.
terraform apply
{% endhighlight %}