---
layout: post
title: Platform Engineering on Kubernetes powered by Terraform, Argo, and FastAPI - Part 1
date: 2024-05-25 13:32:20 +0300
description: Explore the practical implementation of Platform Engineering using powerful tools like Terraform, Argo Events, Argo Workflows
img: i-rest.jpg # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [platformengineering, kubernetes]
---
The cloud-native landscape is constantly evolving, and new concepts often emerge, capturing the attention of the tech community. While some of these concepts are often a repackaging of existing practices, many of them bring meaningful improvements. Platform Engineering is one of them, offering an innovative approach to empowering software engineering organizations in the cloud-native era.

In practical terms, Platform Engineering focuses on designing and building toolchains and workflows that enable self-service capabilities for software engineering teams. Platform engineers provide an integrated product most often referred to as an “Internal Developer Platform” covering the operational necessities of the entire lifecycle of an application.

In this multi-part series, we'll dive deep into a practical implementation of Platform Engineering by building an internal developer platform (IDP) using common tools that platform and DevOps engineers are already familiar with, such as Terraform, Argo Events, Argo Workflows, and FastAPI.

## Table of Contents
- [What we are building ](#what-we-are-building)
- [Capabilities](#capabilities)
- [Building blocks ](#building-blocks)
- [Prerequisites ](#prerequisites)
- [Implementation ](#implementation)
- [Summary ](#summary)

## What we are building
**A Unified Developer Experience:** Imagine a centralized platform where developers can call an api to provision and manage infrastructure, automate workflows, and build and deploy applications with ease. This platform would serve as a one-stop shop, eliminating the need for disparate tools and manual processes, ultimately reducing complexity and increasing productivity. The figure below provides a step-by-step illustration of what we will be building in this multi-part series.

![image](https://github.com/musana-engineering/musana.engineering.github.io/assets/42842390/2db597b3-3db9-4d33-aa47-43de18dd7b84)

## Capabilities
Our internal developer platform will be built to include 5 core capabilities.

- **Infrastructure provisioning:** Enable developers to create cloud infrastructure resources that adhere to security and performance best practices while abstracting complexities such  as networking and security.  

- **Environment Deployment:** Enable developers to create new and fully provisioned environments whenever needed and also delete them when nolonger needed.

- **Application Deployment:** Enable developers to deploy applications based on various events, such as code commits or manual triggers,

- **Application Configuration:** Enable developers configure applications based on various events, such as code commits or manual triggers

- **Access Control:** Manage who can do what in a scalable way.

## Building blocks
Before diving into the implementation details, let's familiarize ourselves with the key tools and technologies that will power our internal developer platform.

- **Kubernetes:** Kubernetes will serve as the underlying foundation upon which our internal developer platform will be built. Kubernetes provides a strong and scalable environment for deploying and managing the various components of our solution, including Terraform, Argo Events, Argo Workflows, and FastAPI.

- **Terraform:** All cloud infrastructure resources created through our platform are defined and managed by Terraform. This process is abstracted from the developer and occurs seamlessly behind the scenes when an API endpoint is called, such as when creating a virtual machine. We chose Terraform for its ability to ensure consistency, reproducibility, and version contro. You can read more about terraform **[here](https://www.terraform.io/)**

- **Argo Events:** Argo Events, an event-driven workflow automation framework for Kubernetes, will enable us to build event-driven applications and workflows. It seamlessly integrates with various event sources, such as webhooks, message queues, and Kubernetes resources, allowing us to trigger actions and workflows based on specific events. In our implementation, Argo Events will react to events generated by developers interacting with the FastAPI endpoints, enabling automated workflows and orchestration. You can read more **[here](https://argoproj.github.io/argo-events/)**

- **Argo Workflows:** Argo Workflows, a container-native workflow engine, will be our CI/CD pipelining solution.This includes cloud resource provisioning, configuration, and application deployments. Using Argo Workflow templates, we will create Terraform tasks for provisioning and Ansible scripts for configuration. You can read more **[here](https://argoproj.github.io/workflows/)**

- **FastAPI:** FastAPI, a modern and high-performance web framework for building APIs with Python, will be the frontend of our internal developer platform. Developers will interact with the platform's capabilities through intuitive APIs exposed by FastAPI. Additionally, FastAPI's built-in Swagger UI will provide a user-friendly interface for exploring and testing the available APIs, fostering self-service. You can read more **[here](https://fastapi.tiangolo.com/)**

## Prerequisites
To follow along with this multi-part series and implement the solution described above, we'll be using Microsoft Azure and Azure Kubernetes Service (AKS). To get started, you'll need the following prerequisites:

- A Microsoft Azure account with an active subscription. If you don't have an Azure account, you can sign up for **[a free trial](https://azure.microsoft.com/en-us/pricing/offers/ms-azr-0044p)**
- Ensure that you have the necessary permissions and access to create and manage resources within your Azure subscription.
- While not strictly required, I recommend using a modern code editor like **Visual Studio Code.** This will make it easier to work with the code samples and configuration files provided throughout the series.

**Note:** Having a good understanding of Kubernetes concepts and architecture will be beneficial as we'll be deploying and interacting with Kubernetes throughout the series. Please note the principles and tools discussed in this series are transferable to other cloud providers and Kubernetes distributions, allowing you to adapt the solution to your preferred environment.

## Implementation
- ### Laying the foundation
In this first part of the series, we'll focus on setting up the foundational infrastructure and services required for our internal developer platform implementation.

We'll start by defining our infrastructure requirements using Terraform's declarative language. This includes provisioning a Kubernetes cluster, configuring networking and security settings, and setting up any necessary storage or database resources.

- ### Architecture

- ### Deploy the foundation
To deploy our infrastructure, follow the steps below
```
git clone https://github.com/musana-engineering/internaldevplatform.git
cd internaldevplatform/platform/core
export SUBSCRIPTION_ID="< subscription id >"
az login
az set subscription -s $SUBSCRIPTION_ID
az ad sp create-for-rbac --role="Contributor" --scopes="/subscriptions/$SUBSCRIPTION_ID"
export ARM_CLIENT_ID="00000000-0000-0000-0000-000000000000"
export ARM_CLIENT_SECRET="12345678-0000-0000-0000-000000000000"
export ARM_TENANT_ID="10000000-0000-0000-0000-000000000000"
export ARM_SUBSCRIPTION_ID="20000000-0000-0000-0000-000000000000"
```