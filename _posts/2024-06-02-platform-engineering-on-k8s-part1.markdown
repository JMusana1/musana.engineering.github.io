---
layout: post
title: Platform Engineering on Kubernetes powered by Terraform, Argo, and FastAPI - Part 1
date: 2024-06-2 13:32:20 +0300
description: Explore the practical implementation of Platform Engineering using powerful tools like Terraform, Argo Events, Argo Workflows
img: i-rest.jpg # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [platformengineering, kubernetes]
---
The cloud-native landscape is constantly evolving, and new concepts often emerge, capturing the attention of the tech community. While some of these concepts are often a repackaging of existing practices, many of them bring meaningful improvements. Platform Engineering is one of them, offering an innovative approach to empowering software engineering organizations in the cloud-native era.

In practical terms, Platform Engineering focuses on designing and building toolchains and workflows that enable self-service capabilities for software engineering teams. Platform engineers provide an integrated product most often referred to as an “Internal Developer Platform” covering the operational necessities of the entire lifecycle of an application.

In this multi-part series, we'll dive deep into a practical implementation of Platform Engineering by building an internal developer platform (IDP) using common tools that platform and DevOps engineers are already familiar with, such as Terraform, Argo Events, Argo Workflows, and FastAPI.

## Table of Contents
- [Introduction ](#introduction)
  - [Platform Components](#platform-components)
  - [Platform Tools ](#platform-tools)
  - [Prerequisites ](#prerequisites)
- [Implementation ](#implementation)
  - [Foundation Architecture ](#foundation-architecture)
  - [Deployment Steps ](#deployment-steps)
  - [TLS Certificate Management ](#tls-certificate-management)
  - [Ingress Management ](#ingress-management)
  - [Secret Management ](#ingress-management)
- [Summary ](#summary)

## Introduction
**A Unified Developer Experience:** Imagine a centralized platform where developers can call an api to provision and manage infrastructure, automate workflows, and build and deploy applications with ease. This platform would serve as a one-stop shop, eliminating the need for disparate tools and manual processes, ultimately reducing complexity and increasing productivity. The figure below provides a step-by-step illustration of what we will be building in this multi-part series.

![main](https://github.com/musana-engineering/idp/assets/151420844/e164cc3b-c7e9-4289-a9fc-a85d41369da1)

## Platform Components
Our internal developer platform will be built to include 5 core capabilities.

- **Infrastructure provisioning:** Enable developers to create cloud infrastructure resources that adhere to security and performance best practices while abstracting complexities such  as networking and security.  

- **Environment Deployment:** Enable developers to create new and fully provisioned environments whenever needed and also delete them when nolonger needed.

- **Application Deployment:** Enable developers to deploy applications based on various events, such as code commits or manual triggers,

- **Application Configuration:** Enable developers configure applications based on various events, such as code commits or manual triggers

- **Access Control:** Manage who can do what in a scalable way.

## Platform Tools
Before diving into the implementation details, let's familiarize ourselves with the key tools and technologies that will power our internal developer platform.

- **[Kubernetes](https://kubernetes.io/)**, an open source system for automating deployment, scaling, and management of containerized applications will be the underlying foundation upon which our internal developer platform will be built. All the components of our solution, including Terraform, Argo Events, Argo Workflows, and FastAPI will be running on Kubernetes

- **[Terraform](https://www.terraform.io/)**, an infrastructure as code tool will be used to define and manage all cloud infrastructure resources created through our platform. This process will be abstracted from the developer and occur seamlessly behind the scenes when an API endpoint is called, such as when creating a dev environment

- **[Argo Events](https://argoproj.github.io/argo-events/)**, an event-driven workflow automation framework for Kubernetes, will enable us to build event-driven applications and workflows. It seamlessly integrates with various event sources, such as webhooks, message queues, and Kubernetes resources, allowing us to trigger actions and workflows based on specific events. In our implementation, Argo Events will react to events generated by developers interacting with the FastAPI endpoints, enabling automated workflows and orchestration.

- **[Argo Workflows](https://argoproj.github.io/workflows/)**, a container-native workflow engine, will be our CI/CD pipelining solution.This includes cloud resource provisioning, configuration, and application deployments. Using Argo Workflow templates, we will create Terraform tasks for provisioning and Ansible scripts for configuration.

- **[FastAPI](https://fastapi.tiangolo.com/)**, a modern high-performance web framework for building APIs with Python, will be the frontend of our internal developer platform. Developers will interact with the platform's capabilities through intuitive APIs exposed by FastAPI. Additionally, FastAPI's built-in Swagger UI will provide a user-friendly interface for exploring and testing the available APIs, fostering self-service. 

## Prerequisites
To follow along with this multi-part series and implement the solution described above, we'll be using Microsoft Azure and Azure Kubernetes Service (AKS). To get started, you'll need the following prerequisites:

- **[A Microsoft Azure](https://azure.microsoft.com/en-us/pricing/offers/ms-azr-0044p)** account with an active subscription and necessary permissions to create and manage resources.
- **[Kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/)**, a command-line tool for interacting with your Kubernetes cluster.
- **[jq](https://jqlang.github.io/jq/)**, a lightweight and flexible command-line JSON processor.
- **[Helm](https://jqlang.github.io/jq/)**, a package manager for Kubernetes that simplifies the process of managing Kubernetes applications.
- **[Visual Studio Code](https://code.visualstudio.com/)** to make it easier to work with the code samples and configuration files provided throughout the series.

**Note:** Having a good understanding of Kubernetes concepts and architecture will be beneficial as we'll be deploying and interacting with Kubernetes throughout the series. Please note the principles and tools discussed in this series are transferable to other cloud providers and Kubernetes distributions, allowing you to adapt the solution to your preferred environment.

## Implementation: 
In this first part of the series, we’ll focus on setting up the foundational infrastructure and services required for our internal developer platform implementation in Microsoft Azure. We will define our infrastructure requirements using Terraform. This includes provisioning a Virtual Network, Azure Kubernetes cluster, configuring network security settings and setting up the necessary storage resources.

- ### Foundation Architecture
![idp-network](https://github.com/musana-engineering/idp/assets/151420844/e448acb6-7001-4cba-a0a6-59ccb9af21c2)
### Deployment steps
- ### Start by deploying the core network.
Create an **[Azure service principal](https://learn.microsoft.com/en-us/cli/azure/azure-cli-sp-tutorial-1?tabs=bash)** to be used for Terraform provider authentication
{% highlight javascript %}
// Login to Azure CLI and set the subscription to use
az login
az account set -s "your_subscription_id_here"

// Set the following Environment Variables
export ARM_CLIENT_ID="your_client_id_here"
export ARM_CLIENT_SECRET="your_client_secret_here"
export ARM_TENANT_ID="your_tenant_id_here"

// Clone the project repository
git clone https://github.com/musana-engineering/idp.git

// Navigate to the network directory
cd idp/core/network

// Generate and review the Terraform plan
terraform init && terraform plan

// Provision the infrastructure.
terraform apply
{% endhighlight %}
- ### Next, deploy the Kubernetes cluster.
{% highlight javascript %}
// Navigate to the aks directory
cd idp/core/aks

// Generate and review the Terraform plan
terraform init && terraform plan

// Provision the infrastructure.
terraform apply
{% endhighlight %}
- ### Next, deploy the platform tools.
![platform_tools](https://github.com/musana-engineering/idp/assets/151420844/81dac169-b1b7-4ec7-80c0-a23b12962bb1)
{% highlight javascript %}
// Navigate to the aks directory
cd idp/core/tools

// Generate and review the Terraform plan
terraform init && terraform plan

// Provision the infrastructure.
terraform apply
{% endhighlight %}

 - ### TLS Certificate Management
Securing our applications with SSL/TLS certificates is a critical aspect of our Platform. Cert-manager will facilitate creating the Certificate resources which includes the issuance, renewal, and management of SSL/TLS certificates from various certificate authorities. 

Upon obtaining the certificate from Letsencrypt, Cert Manager securely stores it as a Kubernetes secret within the Cert-Manager namespace. However, to meet the diverse needs of our platform, we require the certificate to be accessible across multiple namespaces. To achieve this, we will leverage the  **[Kubernetes Replicator](https://github.com/mittwald/kubernetes-replicator)**, enabling seamless replication of secrets throughout our Kubernetes environment.

 - ### Secret Management
Safeguarding sensitive data is crucial for our platform's security. We've chosen Azure Key Vault as our centralized repository for securely storing all secrets, leveraging industry-standard encryption and access control.

To seamlessly integrate Azure Key Vault with our Kubernetes clusters, we'll utilize External Secrets. This solution bridges Kubernetes and Azure Key Vault, allowing us to securely retrieve secrets directly into the relevant namespaces without compromising security or increasing complexity.

First, we'll set up a ClusterSecretStore for our Azure Key Vault within our Kubernetes environment, establishing a secure connection for retrieving secrets. Then, we'll create ExternalSecrets for the specific secrets required by our applications, ensuring sensitive data remains protected yet accessible within the appropriate namespaces.

 - ### Ingress Management
Routing incoming traffic to the appropriate services within our Platform will be handled by Nginx Ingress, a popular ingress controller for Kubernetes. With its advanced features, such as SSL/TLS termination, path-based routing, and support for custom configurations, Nginx Ingress provides a robust and flexible solution for exposing our applications to the outside world.